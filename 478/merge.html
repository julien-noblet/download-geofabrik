
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>download-geofabrik: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/julien-noblet/download-geofabrik/cmd/download-geofabrik/main.go (0.0%)</option>
				
				<option value="file1">github.com/julien-noblet/download-geofabrik/internal/cli/download.go (0.0%)</option>
				
				<option value="file2">github.com/julien-noblet/download-geofabrik/internal/cli/generate.go (0.0%)</option>
				
				<option value="file3">github.com/julien-noblet/download-geofabrik/internal/cli/list.go (0.0%)</option>
				
				<option value="file4">github.com/julien-noblet/download-geofabrik/internal/cli/root.go (0.0%)</option>
				
				<option value="file5">github.com/julien-noblet/download-geofabrik/internal/config/config.go (75.3%)</option>
				
				<option value="file6">github.com/julien-noblet/download-geofabrik/internal/downloader/download.go (67.6%)</option>
				
				<option value="file7">github.com/julien-noblet/download-geofabrik/internal/downloader/hash.go (65.7%)</option>
				
				<option value="file8">github.com/julien-noblet/download-geofabrik/internal/element/element.go (100.0%)</option>
				
				<option value="file9">github.com/julien-noblet/download-geofabrik/internal/generator/generator.go (36.4%)</option>
				
				<option value="file10">github.com/julien-noblet/download-geofabrik/internal/generator/importer/geofabrik/geofabrik.go (80.9%)</option>
				
				<option value="file11">github.com/julien-noblet/download-geofabrik/internal/lists/lists.go (90.5%)</option>
				
				<option value="file12">github.com/julien-noblet/download-geofabrik/internal/scrapper/bbbike/bbbike.go (80.0%)</option>
				
				<option value="file13">github.com/julien-noblet/download-geofabrik/internal/scrapper/geofabrik/geofabrik.go (88.5%)</option>
				
				<option value="file14">github.com/julien-noblet/download-geofabrik/internal/scrapper/openstreetmapfr/openstreetmapfr.go (93.4%)</option>
				
				<option value="file15">github.com/julien-noblet/download-geofabrik/internal/scrapper/osmtoday/osmtoday.go (80.0%)</option>
				
				<option value="file16">github.com/julien-noblet/download-geofabrik/internal/scrapper/scrapper.go (88.1%)</option>
				
				<option value="file17">github.com/julien-noblet/download-geofabrik/pkg/formats/formats.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "github.com/julien-noblet/download-geofabrik/internal/cli"
)

func main() <span class="cov0" title="0">{
        cli.Execute()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cli

import (
        "context"
        "fmt"
        "log/slog"
        "os"

        config "github.com/julien-noblet/download-geofabrik/internal/config"
        downloader "github.com/julien-noblet/download-geofabrik/internal/downloader"
        "github.com/julien-noblet/download-geofabrik/pkg/formats"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        // Flags for download command.
        outputDir        string
        check            bool
        noDownload       bool
        downloadProgress bool
        // Format flags.
        formatFlags = make(map[string]*bool)
)

var downloadCmd = &amp;cobra.Command{
        Use:   "download [element]",
        Short: "Download element",
        Args:  cobra.ExactArgs(1),
        RunE:  runDownload,
}

func RegisterDownloadCmd() <span class="cov0" title="0">{
        rootCmd.AddCommand(downloadCmd)

        downloadCmd.Flags().StringVarP(&amp;outputDir, "output-dir", "d", "", "Set output directory")
        downloadCmd.Flags().BoolVar(&amp;check, "check", true, "Control with checksum (default). Use --no-check to discard control")
        downloadCmd.Flags().BoolVarP(&amp;noDownload, "nodownload", "n", false, "Do not download file (test only)")
        downloadCmd.Flags().BoolVar(&amp;downloadProgress, "progress", true, "Show progress bar")

        // Add format flags
        // These mimic the original kingpin flags
        addFormatFlag(formats.KeyOsmPbf, "P", "Download osm.pbf (default)")
        addFormatFlag(formats.KeyOshPbf, "H", "Download osh.pbf")
        addFormatFlag(formats.KeyOsmGz, "G", "Download osm.gz")
        addFormatFlag(formats.KeyOsmBz2, "B", "Download osm.bz2")
        addFormatFlag(formats.KeyShpZip, "S", "Download shp.zip")
        addFormatFlag(formats.KeyState, "s", "Download state.txt")
        addFormatFlag(formats.KeyPoly, "p", "Download poly")
        addFormatFlag(formats.KeyKml, "k", "Download kml")
        addFormatFlag(formats.KeyGeoJSON, "g", "Download GeoJSON")
        addFormatFlag(formats.KeyGarminOSM, "O", "Download Garmin OSM")

        // Others...
        addFormatFlag(formats.KeyMapsforge, "m", "Download Mapsforge")
        addFormatFlag(formats.KeyMBTiles, "M", "Download MBTiles")
        addFormatFlag(formats.KeyCSV, "C", "Download CSV")
        addFormatFlag(formats.KeyGarminOnroad, "r", "Download Garmin Onroad")
        addFormatFlag(formats.KeyGarminOntrail, "t", "Download Garmin Ontrail")
        addFormatFlag(formats.KeyGarminOpenTopo, "o", "Download Garmin OpenTopo")
}</span>

func addFormatFlag(key, shorthand, usage string) <span class="cov0" title="0">{
        val := false
        formatFlags[key] = &amp;val
        downloadCmd.Flags().BoolVarP(&amp;val, key, shorthand, false, usage)
}</span>

func runDownload(_ *cobra.Command, args []string) error <span class="cov0" title="0">{
        elementID := args[0]

        // Prepare Options
        // Note: rootCmd flags (config file, verbose) should be parsed already.
        // I need to access them. They are bound to Viper in root.go (I need to ensure that).

        cfgFile := viper.GetString("config")
        if cfgFile == "" </span><span class="cov0" title="0">{
                cfgFile = config.DefaultConfigFile
        }</span>

        <span class="cov0" title="0">opts := &amp;config.Options{
                ConfigFile:      cfgFile,
                OutputDirectory: outputDir,
                Check:           check,
                Verbose:         viper.GetBool("verbose"),
                Quiet:           viper.GetBool("quiet"),
                NoDownload:      noDownload,
                Progress:        downloadProgress,
                FormatFlags:     make(map[string]bool),
        }

        // Fill format flags
        for k, v := range formatFlags </span><span class="cov0" title="0">{
                opts.FormatFlags[k] = *v
        }</span>

        // Ensure output dir has separator?
        <span class="cov0" title="0">if opts.OutputDirectory == "" </span><span class="cov0" title="0">{
                wd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get working directory: %w", err)
                }</span>

                <span class="cov0" title="0">opts.OutputDirectory = wd + string(os.PathSeparator)</span>
        } else<span class="cov0" title="0"> if opts.OutputDirectory[len(opts.OutputDirectory)-1] != os.PathSeparator </span><span class="cov0" title="0">{
                opts.OutputDirectory += string(os.PathSeparator)
        }</span>

        // Load Config
        <span class="cov0" title="0">cfg, err := config.LoadConfig(opts.ConfigFile)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load config", "file", opts.ConfigFile, "error", err)

                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Determine active formats
        <span class="cov0" title="0">activeFormats := formats.GetFormats(opts.FormatFlags)

        downloaderInstance := downloader.NewDownloader(cfg, opts)

        ctx := context.Background()

        for _, format := range activeFormats </span><span class="cov0" title="0">{
                // Filename calculation?
                // original used `GetFilename`.
                // `filename := GetFilename(viper.GetString(viperOutputDirectoryKey), viper.GetString(viperElementKey))`

                // I should reconstruct the file path.
                // `Downloader.DownloadFile` takes outputPath (e.g. dir/elementName.ext) or just dir/elementName?
                // My implementation of `DownloadFile` takes `outputPath`.
                // And checks `format` ID from config.

                // Construct the base filename (without extension).
                // Original: `r.FindStringSubmatch(outputDir + element)[0]` -&gt; basically basename of element?
                // No, if element is path?

                // Construct the base filename (without extension).
                outFile := opts.OutputDirectory + elementID
                // Get format details for extension
                formatDef := cfg.Formats[format]
                targetFile := outFile + "." + formatDef.ID

                slog.Info("Processing", "element", elementID, "format", format)

                if err := processDownload(ctx, downloaderInstance, opts.Check, elementID, format, targetFile); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func processDownload(ctx context.Context, downloaderInstance *downloader.Downloader, check bool, elementID, format, targetFile string) error <span class="cov0" title="0">{
        if !check </span><span class="cov0" title="0">{
                if err := downloaderInstance.DownloadFile(ctx, elementID, format, targetFile); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("download failed: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">shouldDownload := true

        if downloader.FileExist(targetFile) </span><span class="cov0" title="0">{
                if downloaderInstance.Checksum(ctx, elementID, format) </span><span class="cov0" title="0">{
                        slog.Info("File already exists and checksum matches", "file", targetFile)

                        shouldDownload = false
                }</span> else<span class="cov0" title="0"> {
                        slog.Warn("Checksum mismatch or verification failed, re-downloading", "file", targetFile)
                }</span>
        }

        <span class="cov0" title="0">if shouldDownload </span><span class="cov0" title="0">{
                if err := downloaderInstance.DownloadFile(ctx, elementID, format, targetFile); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("download failed: %w", err)
                }</span>
                // Verify again
                <span class="cov0" title="0">downloaderInstance.Checksum(ctx, elementID, format)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cli

import (
        "fmt"
        "log/slog"

        "github.com/julien-noblet/download-geofabrik/internal/config"
        "github.com/julien-noblet/download-geofabrik/internal/generator"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        service          string
        generateProgress bool
)

var generateCmd = &amp;cobra.Command{
        Use:   "generate",
        Short: "Generate configuration file",
        RunE:  runGenerate,
}

func RegisterGenerateCmd() <span class="cov0" title="0">{
        rootCmd.AddCommand(generateCmd)
        generateCmd.Flags().StringVarP(&amp;service, "service", "s", "geofabrik",
                "Service to use (geofabrik, geofabrik-parse, openstreetmap.fr, osmtoday, bbbike)")
        generateCmd.Flags().BoolVarP(&amp;generateProgress, "progress", "p", true, "Show progress bar")
}</span>

func runGenerate(_ *cobra.Command, _ []string) error <span class="cov0" title="0">{
        cfgFile := viper.GetString("config")
        if cfgFile == "" </span><span class="cov0" title="0">{
                cfgFile = config.DefaultConfigFile
        }</span>

        <span class="cov0" title="0">slog.Info("Generating config", "service", service, "file", cfgFile)

        if err := generator.Generate(service, generateProgress, cfgFile); err != nil </span><span class="cov0" title="0">{
                slog.Error("Generation failed", "error", err)

                return fmt.Errorf("generation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cli

import (
        "fmt"
        "log/slog"

        "github.com/julien-noblet/download-geofabrik/internal/config"
        "github.com/julien-noblet/download-geofabrik/internal/lists"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var markdown bool

var listCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "Show elements available",
        RunE:  runList,
}

func RegisterListCmd() <span class="cov0" title="0">{
        rootCmd.AddCommand(listCmd)
        listCmd.Flags().BoolVar(&amp;markdown, "markdown", false, "Generate list in Markdown format")
}</span>

func runList(_ *cobra.Command, _ []string) error <span class="cov0" title="0">{
        cfgFile := viper.GetString("config")
        if cfgFile == "" </span><span class="cov0" title="0">{
                cfgFile = config.DefaultConfigFile
        }</span>

        <span class="cov0" title="0">opts := &amp;config.Options{
                ConfigFile: cfgFile,
        }

        cfg, err := config.LoadConfig(opts.ConfigFile)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load config", "file", opts.ConfigFile, "error", err)

                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">format := ""
        if markdown </span><span class="cov0" title="0">{
                format = lists.MarkdownFormat
        }</span>

        <span class="cov0" title="0">if err := lists.ListAllRegions(cfg, format); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to list all regions", "error", err)

                return fmt.Errorf("failed to list regions: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cli

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
)

var rootCmd = &amp;cobra.Command{
        Use:   "download-geofabrik",
        Short: "A command-line tool for downloading OSM files",
        Long:  `download-geofabrik is a CLI tool that downloads OpenStreetMap data from Geofabrik.`,
        RunE: func(cmd *cobra.Command, _ []string) error <span class="cov0" title="0">{
                return cmd.Help()
        }</span>,
}

// Execute adds all child commands to the root command and sets flags appropriately.
func Execute() <span class="cov0" title="0">{
        RegisterDownloadCmd()
        RegisterGenerateCmd()
        RegisterListCmd()

        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "errors"
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "reflect"
        "strings"
        "sync"

        "github.com/julien-noblet/download-geofabrik/internal/element"
        "github.com/julien-noblet/download-geofabrik/pkg/formats"
        "gopkg.in/yaml.v3"
)

const (
        DefaultConfigFile = "geofabrik.yml"
        DefaultService    = "geofabrik"
)

var (
        ErrElem2URL       = errors.New("can't find url")
        ErrLoadConfig     = errors.New("can't load config")
        ErrFindElem       = errors.New("element not found")
        ErrParentMismatch = errors.New("can't merge")
        ErrFormatNotExist = errors.New("format not exist")

        hashes = []string{"md5"}
)

// Config structure handles all elements and formats from the YAML database.
type Config struct {
        Formats       formats.FormatDefinitions `yaml:"formats"`
        Elements      element.MapElement        `yaml:"elements"`
        ElementsMutex *sync.RWMutex             `yaml:"-"`       // unexported
        BaseURL       string                    `yaml:"baseURL"` //nolint:tagliatelle // external yaml requirement
}

// Options holds runtime configuration (flags).
// Field alignment optimized.
type Options struct {
        FormatFlags     map[string]bool
        ConfigFile      string
        Service         string
        OutputDirectory string
        Check           bool
        Verbose         bool
        Quiet           bool
        NoDownload      bool
        Progress        bool
}

// Generate Yaml config.
func (config *Config) Generate() ([]byte, error) <span class="cov2" title="3">{
        yml, err := yaml.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to Marshal: %w", err)
        }</span>

        <span class="cov2" title="3">return yml, nil</span>
}

// MergeElement merges a new element into the config.
func (config *Config) MergeElement(elementPtr *element.Element) error <span class="cov10" title="1129">{
        config.ElementsMutex.RLock()
        newElement, ok := config.Elements[elementPtr.ID]
        config.ElementsMutex.RUnlock()

        if ok </span><span class="cov5" title="44">{
                if newElement.Parent != elementPtr.Parent </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: Parent mismatch %s != %s (%s)", ErrParentMismatch, newElement.Parent, elementPtr.Parent, elementPtr.ID)
                }</span>

                <span class="cov5" title="44">config.ElementsMutex.Lock()
                defer config.ElementsMutex.Unlock()

                for _, f := range elementPtr.Formats </span><span class="cov6" title="104">{
                        if !newElement.Formats.Contains(f) </span><span class="cov5" title="44">{
                                newElement.Formats = append(newElement.Formats, f)
                        }</span>
                }

                <span class="cov5" title="44">newElement.Meta = len(newElement.Formats) == 0
                config.Elements[elementPtr.ID] = newElement</span>
        } else<span class="cov9" title="1085"> {
                config.ElementsMutex.Lock()
                defer config.ElementsMutex.Unlock()

                config.Elements[elementPtr.ID] = *elementPtr
        }</span>

        <span class="cov10" title="1129">return nil</span>
}

// Exist checks if an element with the given ID exists in the config.
func (config *Config) Exist(elementID string) bool <span class="cov6" title="72">{
        config.ElementsMutex.RLock()
        defer config.ElementsMutex.RUnlock()

        result := reflect.DeepEqual(config.Elements[elementID], element.Element{})

        return !result
}</span>

// AddExtension adds an extension to an element.
func (config *Config) AddExtension(elementID, format string) <span class="cov5" title="47">{
        config.ElementsMutex.RLock()
        elem := config.Elements[elementID]
        config.ElementsMutex.RUnlock()

        if !elem.Formats.Contains(format) </span><span class="cov5" title="45">{
                slog.Info("Add extension to element", "format", format, "id", elem.ID)

                config.ElementsMutex.Lock()

                elem.Formats = append(elem.Formats, format)

                config.ElementsMutex.Unlock()

                if err := config.MergeElement(&amp;elem); err != nil </span><span class="cov0" title="0">{
                        slog.Error("can't merge element", "error", err, "name", elem.Name)
                        os.Exit(1) // Or handle better
                }</span>
        }
}

// GetElement gets an element by ID or returns an error if not found.
func (config *Config) GetElement(elementID string) (*element.Element, error) <span class="cov1" title="1">{
        if config.Exist(elementID) </span><span class="cov1" title="1">{
                config.ElementsMutex.RLock()
                r := config.Elements[elementID]
                config.ElementsMutex.RUnlock()

                return &amp;r, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("%w: %s", ErrFindElem, elementID)</span>
}

// FindElem finds an element in the config by ID.
func FindElem(config *Config, e string) (*element.Element, error) <span class="cov3" title="6">{
        res := config.Elements[e]
        if res.ID == "" || res.ID != e </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %s is not in config. Please use \"list\" command", ErrFindElem, e)
        }</span>

        <span class="cov3" title="6">return &amp;res, nil</span>
}

// GetFile gets the file name of an element.
func GetFile(myElement *element.Element) string <span class="cov2" title="3">{
        if myElement.File != "" </span><span class="cov0" title="0">{
                return myElement.File
        }</span>

        <span class="cov2" title="3">return myElement.ID</span>
}

// Elem2preURL generates a pre-URL for an element.
func Elem2preURL(config *Config, elementPtr *element.Element, baseURL ...string) (string, error) <span class="cov2" title="3">{
        myElement, err := FindElem(config, elementPtr.ID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov2" title="3">if myElement.HasParent() </span><span class="cov0" title="0">{
                parent, err := FindElem(config, myElement.Parent)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">res, err := Elem2preURL(config, parent, baseURL...)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">res += "/" + GetFile(myElement)

                return res, nil</span>
        }

        <span class="cov2" title="3">switch len(baseURL) </span>{
        case 1:<span class="cov0" title="0">
                return config.BaseURL + "/" + strings.Join(baseURL, "/") + GetFile(myElement), nil</span>
        case 2:<span class="cov2" title="3"> //nolint:mnd // This case handles exactly 2 base URL components
                return strings.Join(baseURL, "/") + GetFile(myElement), nil</span>
        default:<span class="cov0" title="0">
                return config.BaseURL + "/" + GetFile(myElement), nil</span>
        }
}

// Elem2URL generates a URL for an element with the given extension.
func Elem2URL(config *Config, elementPtr *element.Element, ext string) (string, error) <span class="cov2" title="3">{
        if !elementPtr.Formats.Contains(ext) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w: %s", ErrFormatNotExist, ext)
        }</span>

        <span class="cov2" title="3">format := config.Formats[ext]
        baseURL, basePath := format.BaseURL, format.BasePath

        if baseURL == "" </span><span class="cov2" title="3">{
                baseURL = config.BaseURL
        }</span>

        <span class="cov2" title="3">res, err := Elem2preURL(config, elementPtr, baseURL, basePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov2" title="3">return res + format.Loc, nil</span>
}

// LoadConfig loads the configuration from the specified file.
func LoadConfig(configFile string) (*Config, error) <span class="cov1" title="1">{
        filename, _ := filepath.Abs(configFile)

        fileContent, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't open %s: %w", filename, err)
        }</span>

        <span class="cov1" title="1">myConfigPtr := &amp;Config{
                Formats:       formats.FormatDefinitions{},
                Elements:      element.MapElement{},
                ElementsMutex: &amp;sync.RWMutex{},
                BaseURL:       "",
        }

        if err := yaml.Unmarshal(fileContent, myConfigPtr); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't unmarshal %s: %w", filename, err)
        }</span>

        <span class="cov1" title="1">return myConfigPtr, nil</span>
}

// IsHashable checks if a format is hashable.
func IsHashable(config *Config, format string) (isHashable bool, hash, extension string) <span class="cov1" title="2">{
        if _, ok := config.Formats[format]; ok </span><span class="cov1" title="2">{
                for _, h := range hashes </span><span class="cov1" title="2">{
                        hash := format + "." + h
                        if _, ok := config.Formats[hash]; ok </span><span class="cov1" title="1">{
                                return true, hash, h
                        }</span>
                }
        }

        <span class="cov1" title="1">return false, "", ""</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package download

import (
        "context"
        "errors"
        "fmt"
        "io"
        "log/slog"
        "net"
        "net/http"
        "os"
        "time"

        pb "github.com/cheggaaa/pb/v3"
        "github.com/julien-noblet/download-geofabrik/internal/config"
)

const (
        progressMinimal = 512 * 1024 // Don't display progress bar if size &lt; 512kb
        defaultTimeout  = 60 * time.Second
        keepAlive       = 30 * time.Second
        idleTimeout     = 5 * time.Second
        tlsTimeout      = 10 * time.Second
        continueTimeout = 5 * time.Second
        fileMode        = 0o644
)

var (
        ErrFromURL          = errors.New("can't download element")
        ErrServerStatusCode = errors.New("server return code error")
)

// Downloader handles downloading files.
type Downloader struct {
        Config  *config.Config
        Options *config.Options
}

// NewDownloader creates a new Downloader.
func NewDownloader(cfg *config.Config, opts *config.Options) *Downloader <span class="cov7" title="5">{
        return &amp;Downloader{
                Config:  cfg,
                Options: opts,
        }
}</span>

// createClient creates a configured HTTP client.
func createClient() *http.Client <span class="cov7" title="5">{
        return &amp;http.Client{
                Transport: &amp;http.Transport{
                        Proxy: http.ProxyFromEnvironment,
                        DialContext: (&amp;net.Dialer{
                                Timeout:   defaultTimeout,
                                KeepAlive: keepAlive,
                                DualStack: true,
                        }).DialContext,
                        MaxIdleConns:          0,
                        IdleConnTimeout:       idleTimeout,
                        TLSHandshakeTimeout:   tlsTimeout,
                        ExpectContinueTimeout: continueTimeout,
                },
        }
}</span>

// FromURL downloads a file from a URL to a specified file path.
func (d *Downloader) FromURL(ctx context.Context, myURL, fileName string) (err error) <span class="cov8" title="6">{
        slog.Debug("Downloading", "url", myURL, "file", fileName)

        if d.Options.NoDownload </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov7" title="5">client := createClient()

        req, err := http.NewRequestWithContext(ctx, http.MethodGet, myURL, http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating request for %s - %w", myURL, err)
        }</span>

        <span class="cov7" title="5">response, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error while downloading %s - %w", myURL, err)
        }</span>

        <span class="cov7" title="5">defer func() </span><span class="cov7" title="5">{
                if cerr := response.Body.Close(); cerr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error while closing response body for %s - %w", myURL, cerr)
                }</span>
        }()

        <span class="cov7" title="5">if response.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                return fmt.Errorf("%w: error while downloading %v, server return code %d",
                        ErrServerStatusCode, myURL, response.StatusCode)
        }</span>

        <span class="cov6" title="4">return d.saveToFile(fileName, response)</span>
}

// saveToFile saves the response body to a file with progress bar support.
func (d *Downloader) saveToFile(fileName string, response *http.Response) (err error) <span class="cov6" title="4">{
        file, err := os.OpenFile(fileName, os.O_CREATE|os.O_WRONLY, fileMode)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error while creating %s - %w", fileName, err)
        }</span>

        <span class="cov6" title="4">defer func() </span><span class="cov6" title="4">{
                if cerr := file.Close(); cerr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error while closing %s - %w", fileName, cerr)
                }</span>
        }()

        <span class="cov6" title="4">var (
                output          io.Writer = file
                currentProgress int64
        )

        // Display progress bar if requested, not quiet, and file is large enough
        if d.Options.Progress &amp;&amp; !d.Options.Quiet &amp;&amp; response.ContentLength &gt; progressMinimal </span><span class="cov0" title="0">{
                progressBar := pb.Full.Start64(response.ContentLength)
                barReader := progressBar.NewProxyReader(response.Body)

                currentProgress, err = io.Copy(output, barReader)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error while writing %s - %w", fileName, err)
                }</span>

                <span class="cov0" title="0">progressBar.Finish()</span>
        } else<span class="cov6" title="4"> {
                currentProgress, err = io.Copy(output, response.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error while writing %s - %w", fileName, err)
                }</span>
        }

        <span class="cov6" title="4">slog.Info("Downloaded", "file", fileName)
        slog.Debug("Bytes downloaded", "bytes", currentProgress)

        return nil</span>
}

// FileExist checks if a file exists at the given path.
func FileExist(filePath string) bool <span class="cov10" title="9">{
        _, err := os.Stat(filePath)

        return err == nil
}</span>

// DownloadFile downloads a file based on the configuration and element.
func (d *Downloader) DownloadFile(ctx context.Context, elementID, formatName, outputPath string) error <span class="cov3" title="2">{
        // elementID and formatName are strings.
        // config.FindElem uses d.Config.
        format := d.Config.Formats[formatName].ID

        myElem, err := config.FindElem(d.Config, elementID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Element not found", "element", elementID, "error", err)

                return fmt.Errorf("%w: %s", config.ErrFindElem, elementID)
        }</span>

        <span class="cov3" title="2">myURL, err := config.Elem2URL(d.Config, myElem, format)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("URL generation failed", "error", err)

                return fmt.Errorf("%w: %w", config.ErrElem2URL, err)
        }</span>

        <span class="cov3" title="2">err = d.FromURL(ctx, myURL, outputPath)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Download failed", "error", err)

                return fmt.Errorf("%w: %w", ErrFromURL, err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// Checksum downloads and verifies the checksum of a file.
func (d *Downloader) Checksum(ctx context.Context, elementID, formatName string) bool <span class="cov5" title="3">{
        if !d.Options.Check </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov3" title="2">hashType := "md5"
        fhash := formatName + "." + hashType

        if ok, _, _ := config.IsHashable(d.Config, formatName); ok </span><span class="cov1" title="1">{
                myElem, err := config.FindElem(d.Config, elementID)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Element not found", "element", elementID, "error", err)

                        return false
                }</span>

                <span class="cov1" title="1">myURL, err := config.Elem2URL(d.Config, myElem, fhash)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("URL generation failed", "error", err)

                        return false
                }</span>

                <span class="cov1" title="1">outputPath := d.Options.OutputDirectory + elementID

                if e := d.FromURL(ctx, myURL, outputPath+"."+fhash); e != nil </span><span class="cov0" title="0">{
                        slog.Error("Checksum download failed", "error", e)

                        return false
                }</span>

                <span class="cov1" title="1">return VerifyFileChecksum(outputPath+"."+d.Config.Formats[formatName].ID, outputPath+"."+fhash)</span>
        }

        <span class="cov1" title="1">slog.Warn("No checksum provided", "file", d.Options.OutputDirectory+elementID+"."+formatName)

        return false</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package download

import (
        "crypto/md5" //nolint:gosec // MD5 is used to control with md5sum files
        "encoding/hex"
        "fmt"
        "io"
        "log/slog"
        "os"
        "strings"
)

const (
        readErrorMsg         = "can't read %s: %w"
        openErrorMsg         = "can't open %s: %w"
        copyErrorMsg         = "can't copy %s: %w"
        closeErrorMsg        = "can't close file: %w"
        hashFileNotFoundMsg  = "Hash file %s not found"
        hashFileReadErrorMsg = "Can't read hash file %s"
        hashMismatchMsg      = "Checksum MISMATCH for %s"
        hashMatchMsg         = "Checksum OK for %s"
        hashingFileMsg       = "Hashing %s"
        md5HashMsg           = "MD5 : %s"
        checksumErrorMsg     = "checksum error"
        hashFileErrorMsg     = "can't hash file"
)

// CheckFileHash checks if the hash of a file matches the provided hash.
func CheckFileHash(hashfile, expectedHash string) (bool, error) <span class="cov8" title="4">{
        if !FileExist(hashfile) </span><span class="cov0" title="0">{
                slog.Warn("Hash file not found", "file", hashfile)

                return false, nil
        }</span>

        <span class="cov8" title="4">fileContent, err := os.ReadFile(hashfile)
        if err != nil </span><span class="cov0" title="0">{
                slog.Warn("Can't read hash file", "file", hashfile, "error", err)

                return false, fmt.Errorf(readErrorMsg, hashfile, err)
        }</span>

        <span class="cov8" title="4">fileHash := strings.Split(string(fileContent), " ")[0]
        slog.Info("Hash from file", "hash", fileHash)

        return strings.EqualFold(expectedHash, fileHash), nil</span>
}

// ComputeMD5Hash computes the MD5 hash of a file.
func ComputeMD5Hash(filePath string) (string, error) <span class="cov10" title="5">{
        if !FileExist(filePath) </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov10" title="5">file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf(openErrorMsg, filePath, err)
        }</span>

        <span class="cov10" title="5">defer func() </span><span class="cov10" title="5">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        slog.Error("Can't close file", "error", err)
                }</span>
        }()

        <span class="cov10" title="5">hash := md5.New() //nolint:gosec // MD5 is used to control with md5sum files
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf(copyErrorMsg, filePath, err)
        }</span>

        <span class="cov10" title="5">return hex.EncodeToString(hash.Sum(nil)), nil</span>
}

// VerifyFileChecksum verifies the checksum of a file.
func VerifyFileChecksum(file, hashfile string) bool <span class="cov4" title="2">{
        slog.Info("Hashing file", "file", file)

        hashed, err := ComputeMD5Hash(file)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Can't hash file", "error", err)

                return false // Was Fatal before
        }</span>

        <span class="cov4" title="2">slog.Debug("MD5 Hash", "hash", hashed)

        ret, err := CheckFileHash(hashfile, hashed)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Checksum error", "error", err)
        }</span>

        <span class="cov4" title="2">if ret </span><span class="cov4" title="2">{
                slog.Info("Checksum OK", "file", file)
        }</span> else<span class="cov0" title="0"> {
                slog.Warn("Checksum MISMATCH", "file", file)
        }</span>

        <span class="cov4" title="2">return ret</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package element

// Element represents a part to download with formats, name, parent, etc.
type Element struct {
        ID      string  `yaml:"id"`
        File    string  `yaml:"file,omitempty"`
        Name    string  `yaml:"name,omitempty"`
        Parent  string  `yaml:"parent,omitempty"`
        Formats Formats `yaml:"files,omitempty"`
        Meta    bool    `yaml:"meta,omitempty"`
}

type Formats []string

// MapElement contains all Elements.
type MapElement map[string]Element

// HasParent checks if the element has a parent.
func (e *Element) HasParent() bool <span class="cov4" title="10">{
        return e.Parent != ""
}</span>

// Contains checks if the format list contains a specific format.
func (f *Formats) Contains(format string) bool <span class="cov9" title="154">{
        for _, existingFormat := range *f </span><span class="cov10" title="223">{
                if format == existingFormat </span><span class="cov7" title="65">{
                        return true
                }</span>
        }

        <span class="cov8" title="89">return false</span>
}

// CreateParentElement creates a parent element for the given element.
// Useful for meta parents.
func CreateParentElement(e *Element, grandparentID string) *Element <span class="cov3" title="4">{
        if e.HasParent() </span><span class="cov2" title="3">{
                return &amp;Element{
                        ID:      e.Parent,
                        File:    "",
                        Name:    e.Parent,
                        Parent:  grandparentID,
                        Formats: Formats{},
                        Meta:    true,
                }
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package generator

import (
        "errors"
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "slices"

        pb "github.com/cheggaaa/pb/v3"
        "github.com/gocolly/colly/v2"
        "github.com/julien-noblet/download-geofabrik/internal/config"
        "github.com/julien-noblet/download-geofabrik/internal/generator/importer/geofabrik"
        "github.com/julien-noblet/download-geofabrik/internal/scrapper"
        "github.com/julien-noblet/download-geofabrik/internal/scrapper/bbbike"
        geofabrikScrapper "github.com/julien-noblet/download-geofabrik/internal/scrapper/geofabrik"
        "github.com/julien-noblet/download-geofabrik/internal/scrapper/openstreetmapfr"
        "github.com/julien-noblet/download-geofabrik/internal/scrapper/osmtoday"
)

const (
        filePermission         = 0o600
        ServiceGeofabrik       = "geofabrik"
        ServiceGeofabrikParse  = "geofabrik-parse"
        ServiceOpenStreetMapFR = "openstreetmap.fr"
        ServiceOSMToday        = "osmtoday"
        ServiceBBBike          = "bbbike"
)

var ErrUnknownService = errors.New("unknown service")

// Write writes the generated configuration to a file.
func Write(c *config.Config, filename string) error <span class="cov1" title="2">{
        out, err := c.Generate()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate config: %w", err)
        }</span>

        <span class="cov1" title="2">filename, err = filepath.Abs(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get absolute path for filename: %w", err)
        }</span>

        <span class="cov1" title="2">if err := os.WriteFile(filename, out, filePermission); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write file: %w", err)
        }</span>

        <span class="cov1" title="2">slog.Info("Generated config file", "file", filename)

        return nil</span>
}

// Generate generates the configuration based on the specified service.
func Generate(service string, progress bool, configfile string) error <span class="cov1" title="1">{
        // The original `Generate` function used a map of handlers.
        // With the refactoring, `PerformGenerate` now encapsulates the logic
        // for all services, including the distinction between Geofabrik and
        // the scrapper-based services.
        // Therefore, `Generate` can directly call `PerformGenerate`.
        return PerformGenerate(service, progress, configfile)
}</span>

// PerformGenerate handles the generation logic for all services.
func PerformGenerate(service string, progress bool, configfile string) error <span class="cov1" title="1">{
        var myScrapper scrapper.IScrapper

        switch service </span>{
        case ServiceGeofabrik:<span class="cov1" title="1">
                return handleGeofabrik(configfile, progress)</span>
        case ServiceGeofabrikParse:<span class="cov0" title="0">
                myScrapper = geofabrikScrapper.GetDefault()</span>
        case ServiceOpenStreetMapFR:<span class="cov0" title="0">
                myScrapper = openstreetmapfr.GetDefault()</span>
        case ServiceOSMToday:<span class="cov0" title="0">
                myScrapper = osmtoday.GetDefault()</span>
        case ServiceBBBike:<span class="cov0" title="0">
                myScrapper = bbbike.GetDefault()</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("%w: %s", ErrUnknownService, service)</span>
        }

        <span class="cov0" title="0">if progress </span><span class="cov0" title="0">{
                handleProgress(myScrapper)
        }</span> else<span class="cov0" title="0"> {
                collector := myScrapper.Collector()
                visitAndWait(collector, myScrapper.GetStartURL())
        }</span>

        <span class="cov0" title="0">myconfig := myScrapper.GetConfig()
        Cleanup(myconfig)

        if err := Write(myconfig, configfile); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to write config", "error", err)

                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleGeofabrik handles the Geofabrik service.
func handleGeofabrik(configfile string, _ bool) error <span class="cov1" title="1">{
        index, err := geofabrik.GetIndex(geofabrik.GeofabrikIndexURL)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to get geofabrik index", "error", err)

                return fmt.Errorf("failed to get index: %w", err)
        }</span>

        <span class="cov1" title="1">myConfig, err := geofabrik.Convert(index)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to convert geofabrik index", "error", err)

                return fmt.Errorf("failed to convert index: %w", err)
        }</span>

        <span class="cov1" title="1">Cleanup(myConfig)

        if err := Write(myConfig, configfile); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to write config", "error", err)

                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// handleProgress handles the progress bar for the scrapper.
func handleProgress(myScrapper scrapper.IScrapper) <span class="cov0" title="0">{
        bar := pb.New(myScrapper.GetPB())
        bar.Start()

        defer bar.Finish()

        collector := myScrapper.Collector()
        collector.OnScraped(func(*colly.Response) </span><span class="cov0" title="0">{
                bar.Increment()
        }</span>)
        <span class="cov0" title="0">visitAndWait(collector, myScrapper.GetStartURL())</span>
}

// visitAndWait visits the URL and waits for the collector to finish.
func visitAndWait(collector *colly.Collector, url string) <span class="cov0" title="0">{
        if err := collector.Visit(url); err != nil </span><span class="cov0" title="0">{
                slog.Error("Can't get url", "error", err)

                return
        }</span>

        <span class="cov0" title="0">collector.Wait()</span>
}

// Cleanup sorts the formats in the configuration elements.
func Cleanup(c *config.Config) <span class="cov2" title="3">{
        for _, elem := range c.Elements </span><span class="cov10" title="514">{
                slices.Sort(elem.Formats)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package geofabrik

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "net"
        "net/http"
        "os"
        "sync"
        "time"

        "github.com/julien-noblet/download-geofabrik/internal/config"
        "github.com/julien-noblet/download-geofabrik/internal/element"
        "github.com/julien-noblet/download-geofabrik/pkg/formats"
)

const (
        GeofabrikIndexURL = `https://download.geofabrik.de/index-v1-nogeom.json`
        GeofabrikBaseURL  = `https://download.geofabrik.de`

        ErrDownload          = "error while downloading %v, server returned code %d\nPlease use '%s generate' to re-create your yml file %w"
        ErrCreatingRequest   = "error while creating request for %s: %w"
        ErrDownloading       = "error while downloading %s: %w"
        ErrReadingResponse   = "error while reading response body: %w"
        ErrUnmarshallingBody = "error while unmarshalling response body: %w"
        ErrMergingElement    = "error while merging element %v: %w"

        TimeoutDuration       = 60 * time.Second
        KeepAliveDuration     = 30 * time.Second
        IdleConnTimeout       = 5 * time.Second
        TLSHandshakeTimeout   = 10 * time.Second
        ExpectContinueTimeout = 5 * time.Second
)

// HTTPClient is a reusable HTTP client.
var HTTPClient = &amp;http.Client{
        Transport: &amp;http.Transport{
                Proxy: http.ProxyFromEnvironment,
                DialContext: (&amp;net.Dialer{
                        Timeout:   TimeoutDuration,
                        KeepAlive: KeepAliveDuration,
                        DualStack: true,
                }).DialContext,
                MaxIdleConns:          0,
                IdleConnTimeout:       IdleConnTimeout,
                TLSHandshakeTimeout:   TLSHandshakeTimeout,
                ExpectContinueTimeout: ExpectContinueTimeout,
        },
}

// FormatDefinition returns a map of format definitions.
func FormatDefinition() formats.FormatDefinitions <span class="cov1" title="2">{
        return formats.FormatDefinitions{
                "osm.bz2.md5":         {ID: "osm.bz2.md5", Loc: "-latest.osm.bz2.md5"},
                "osm.pbf.md5":         {ID: "osm.pbf.md5", Loc: "-latest.osm.pbf.md5"},
                formats.FormatKml:     {ID: formats.FormatKml, Loc: ".kml"},
                formats.FormatMBTiles: {ID: formats.FormatMBTiles, Loc: "-latest-free.mbtiles.zip", ToLoc: "latest-free.mbtiles.zip"},
                formats.FormatOsmBz2:  {ID: formats.FormatOsmBz2, Loc: "-latest.osm.bz2"},
                formats.FormatOsmPbf:  {ID: formats.FormatOsmPbf, Loc: "-latest.osm.pbf"},
                formats.FormatPoly:    {ID: formats.FormatPoly, Loc: ".poly"},
                formats.FormatShpZip:  {ID: formats.FormatShpZip, Loc: "-shortbread-1.0.mbtiles"},
                formats.FormatState:   {ID: formats.FormatState, Loc: "-updates/state.txt"},
        }
}</span>

// Index represents the structure of the Geofabrik index.
type Index struct {
        Features []IndexElement `json:"features"`
}

// IndexElement represents an element in the Geofabrik index.
type IndexElement struct {
        ElementProperties IndexElementProperties `json:"properties"`
}

// IndexElementProperties represents the properties of an index element.
type IndexElementProperties struct {
        Urls      map[string]string `json:"urls"`
        ID        string            `json:"id"`
        Name      string            `json:"name"`
        Parent    string            `json:"parent,omitempty"`
        Iso3166_1 []string          `json:"iso3166-1:alpha2,omitempty"` //nolint:tagliatelle // That's geofabrik's field name
        Iso3166_2 []string          `json:"iso3166-2,omitempty"`        //nolint:tagliatelle // That's geofabrik's field name
}

// GetIndex downloads the Geofabrik index and unmarshals the JSON response.
func GetIndex(url string) (*Index, error) <span class="cov2" title="3">{
        ctx, cancel := context.WithTimeout(context.Background(), TimeoutDuration)
        defer cancel()

        req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(ErrCreatingRequest, url, err)
        }</span>

        <span class="cov2" title="3">response, err := HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(ErrDownloading, url, err)
        }</span>

        <span class="cov2" title="3">defer func() </span><span class="cov2" title="3">{
                if cerr := response.Body.Close(); cerr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("close response: %w", cerr)
                }</span>
        }()

        <span class="cov2" title="3">if response.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                return nil, handleHTTPError(response, url)
        }</span>

        <span class="cov1" title="2">bodyBytes, err := io.ReadAll(response.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(ErrReadingResponse, err)
        }</span>

        <span class="cov1" title="2">var geofabrikIndex Index
        if err := json.Unmarshal(bodyBytes, &amp;geofabrikIndex); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(ErrUnmarshallingBody, err)
        }</span>

        <span class="cov1" title="2">return &amp;geofabrikIndex, nil</span>
}

// handleHTTPError handles HTTP errors based on the status code.
func handleHTTPError(response *http.Response, url string) error <span class="cov1" title="1">{
        switch response.StatusCode </span>{
        case http.StatusNotFound:<span class="cov1" title="1">
                return fmt.Errorf(ErrDownload, url, response.StatusCode, os.Args[0], http.ErrNoLocation)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf(ErrDownload, url, response.StatusCode, os.Args[0], http.ErrNotSupported)</span>
        }
}

// Convert converts the Geofabrik index to a config.Config object.
func Convert(index *Index) (*config.Config, error) <span class="cov1" title="2">{
        cfg := &amp;config.Config{
                Formats:       FormatDefinition(),
                BaseURL:       GeofabrikBaseURL,
                Elements:      element.MapElement{},
                ElementsMutex: &amp;sync.RWMutex{},
        }

        for _, feature := range index.Features </span><span class="cov8" title="1024">{
                if err := processFeature(cfg, &amp;feature); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov1" title="2">return cfg, nil</span>
}

// processFeature processes a single feature from the Geofabrik index.
func processFeature(cfg *config.Config, feature *IndexElement) error <span class="cov8" title="1024">{
        var elem element.Element

        slog.Debug("Processing feature", "ID", feature.ElementProperties.ID)

        elem.ID = feature.ElementProperties.ID
        elem.Parent = feature.ElementProperties.Parent
        elem.Name = feature.ElementProperties.Name

        elem.Formats = append(elem.Formats, getFormats(feature.ElementProperties.Urls)...)

        if err := cfg.MergeElement(&amp;elem); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf(ErrMergingElement, elem, err)
        }</span>

        <span class="cov8" title="1024">return nil</span>
}

// getFormats returns the formats based on the URLs.
func getFormats(urls map[string]string) []string <span class="cov8" title="1024">{
        myFormats := []string{}

        for k := range urls </span><span class="cov10" title="6086">{
                switch k </span>{
                case "pbf":<span class="cov8" title="1024">
                        myFormats = append(myFormats, formats.FormatOsmPbf, "osm.pbf.md5")</span>
                case "bz2":<span class="cov0" title="0">
                        myFormats = append(myFormats, formats.FormatOsmBz2, "osm.bz2.md5")</span>
                case "shp":<span class="cov8" title="966">
                        myFormats = append(myFormats, formats.FormatShpZip)</span>
                case "history":<span class="cov8" title="1024">
                        myFormats = append(myFormats, formats.FormatOshPbf)</span>
                }
        }

        <span class="cov8" title="1024">myFormats = append(myFormats, formats.FormatPoly, formats.FormatKml, formats.FormatState)

        return myFormats</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package lists

import (
        "fmt"
        "os"
        "sort"

        "github.com/julien-noblet/download-geofabrik/internal/config"
        "github.com/julien-noblet/download-geofabrik/pkg/formats"
        "github.com/olekukonko/tablewriter"
        "github.com/olekukonko/tablewriter/tw"
)

const (
        MarkdownFormat = "Markdown"
)

// ListAllRegions lists all regions in the specified format.
func ListAllRegions(configuration *config.Config, format string) error <span class="cov4" title="2">{
        table := CreateTable(format)
        keys := GetSortedKeys(configuration)

        for _, item := range keys </span><span class="cov7" title="4">{
                err := table.Append(
                        item,
                        configuration.Elements[configuration.Elements[item].Parent].Name,
                        configuration.Elements[item].Name,
                        formats.GetMiniFormats(configuration.Elements[item].Formats),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to append: %w", err)
                }</span>
        }

        <span class="cov4" title="2">if err := table.Render(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to render table: %w", err)
        }</span>

        <span class="cov4" title="2">fmt.Printf("Total elements: %#v\n", len(configuration.Elements)) //nolint:forbidigo // I want to print the number of elements

        return nil</span>
}

// CreateTable creates a table with the specified format.
func CreateTable(format string) *tablewriter.Table <span class="cov4" title="2">{
        // Options
        opts := []tablewriter.Option{
                tablewriter.WithHeader([]string{"ShortName", "Is in", "Long Name", "formats"}),
                tablewriter.WithAlignment(tw.MakeAlign(4, tw.AlignLeft)), //nolint:mnd // 4 columns to align left
        }

        if format == MarkdownFormat </span><span class="cov1" title="1">{
                opts = append(opts, tablewriter.WithRendition(tw.Rendition{
                        Symbols: tw.NewSymbols(tw.StyleMarkdown),
                        Borders: tw.Border{
                                Left:   tw.On,
                                Top:    tw.Off,
                                Right:  tw.On,
                                Bottom: tw.Off,
                        },
                }))
        }</span>

        <span class="cov4" title="2">return tablewriter.NewTable(os.Stdout, opts...)</span>
}

// GetSortedKeys returns the sorted keys of the configuration elements.
func GetSortedKeys(configuration *config.Config) []string <span class="cov6" title="3">{
        keys := make(sort.StringSlice, len(configuration.Elements))
        i := 0

        for k := range configuration.Elements </span><span class="cov10" title="6">{
                keys[i] = k
                i++
        }</span>

        <span class="cov6" title="3">keys.Sort()

        return keys</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package bbbike

import (
        "errors"
        "log/slog"
        "regexp"

        "github.com/gocolly/colly/v2"
        "github.com/julien-noblet/download-geofabrik/internal/element"
        "github.com/julien-noblet/download-geofabrik/internal/scrapper"
        "github.com/julien-noblet/download-geofabrik/pkg/formats"
)

// Constants for magic numbers and URLs.
const (
        progressBarCount = 237 // number of elements
        parallelism      = 20  // number of parallel downloads
        prefixLength     = 17  // length of "OSM extracts for "
        baseURL          = "https://download.bbbike.org/osm/bbbike"
        startURL         = baseURL + "/"
)

// Bbbike Scrapper.
type Bbbike struct {
        *scrapper.Scrapper
}

// GetDefault returns the default configuration for Bbbike scrapper.
func GetDefault() *Bbbike <span class="cov2" title="2">{
        urlFilters := []*regexp.Regexp{
                regexp.MustCompile(`https://download\.bbbike\.org/osm/bbbike/[A-Z].+$`),
                regexp.MustCompile(`https://download\.bbbike\.org/osm/bbbike/$`),
        }

        formatDefinition := formats.FormatDefinitions{
                formats.FormatCSV:            {ID: formats.FormatCSV, Loc: ".osm.csv.xz", ToLoc: ".osm.csv.xz"},
                formats.FormatGarminOSM:      {ID: formats.FormatGarminOSM, Loc: ".osm.garmin-osm.zip"},
                formats.FormatGarminOnroad:   {ID: formats.FormatGarminOnroad, Loc: ".osm.garmin-onroad-latin1.zip"},
                formats.FormatGarminOntrail:  {ID: formats.FormatGarminOntrail, Loc: ".osm.garmin-ontrail-latin1.zip"},
                formats.FormatGarminOpenTopo: {ID: formats.FormatGarminOpenTopo, Loc: ".osm.garmin-opentopo-latin1.zip"},
                formats.FormatGeoJSON:        {ID: formats.FormatGeoJSON, Loc: ".osm.geojson.xz", ToLoc: ".geojson.xz"},
                formats.FormatMBTiles:        {ID: formats.FormatMBTiles, Loc: ".osm.mbtiles-openmaptiles.zip", ToLoc: "osm.mbtiles-openmaptiles.zip"},
                formats.FormatMapsforge:      {ID: formats.FormatMapsforge, Loc: ".osm.mapsforge-osm.zip"},
                formats.FormatOsmGz:          {ID: formats.FormatOsmGz, Loc: ".osm.gz"},
                formats.FormatOsmPbf:         {ID: formats.FormatOsmPbf, Loc: ".osm.pbf"},
                formats.FormatPoly:           {ID: formats.FormatPoly, Loc: ".poly"},
                formats.FormatShpZip:         {ID: formats.FormatShpZip, Loc: ".osm.shp.zip"},
        }

        return &amp;Bbbike{
                Scrapper: &amp;scrapper.Scrapper{
                        PB:               progressBarCount,
                        Async:            true,
                        Parallelism:      parallelism,
                        MaxDepth:         0,
                        AllowedDomains:   []string{`download.bbbike.org`},
                        BaseURL:          baseURL,
                        StartURL:         startURL,
                        URLFilters:       urlFilters,
                        FormatDefinition: formatDefinition,
                },
        }
}</span>

// Collector represents Bbbike's scrapper.
func (b *Bbbike) Collector() *colly.Collector <span class="cov2" title="2">{
        myCollector := b.Scrapper.Collector()
        myCollector.OnHTML("div.list tbody", func(e *colly.HTMLElement) </span><span class="cov0" title="0">{
                b.ParseList(e, myCollector)
        }</span>)
        <span class="cov2" title="2">myCollector.OnHTML("#sidebar", func(e *colly.HTMLElement) </span><span class="cov0" title="0">{
                b.ParseSidebar(e, myCollector)
        }</span>)

        <span class="cov2" title="2">return myCollector</span>
}

// ParseList parses the list of elements from the HTML.
func (b *Bbbike) ParseList(e *colly.HTMLElement, c *colly.Collector) <span class="cov1" title="1">{
        e.ForEach("a", func(_ int, el *colly.HTMLElement) </span><span class="cov10" title="236">{
                href := el.Request.AbsoluteURL(el.Attr("href"))
                slog.Debug("Parse", "href", href)

                if err := c.Visit(href); err != nil &amp;&amp; !errors.Is(err, colly.ErrNoURLFiltersMatch) </span><span class="cov0" title="0">{
                        slog.Error("Can't get url", "error", err)
                }</span>
        })
}

// GetName extracts the name from the given string.
func GetName(h3 string) string <span class="cov2" title="2">{
        return h3[prefixLength:] // remove "OSM extracts for "
}</span>

// ParseSidebar parses the sidebar information from the HTML.
func (b *Bbbike) ParseSidebar(e *colly.HTMLElement, _ *colly.Collector) <span class="cov1" title="1">{
        name := GetName(e.ChildText("h3"))
        myElement := element.Element{
                ID:     name,
                Name:   name,
                File:   name + "/" + name,
                Parent: "",
                Formats: element.Formats{
                        formats.FormatCSV,
                        formats.FormatGarminOSM,
                        formats.FormatGarminOnroad,
                        formats.FormatGarminOntrail,
                        formats.FormatGarminOpenTopo,
                        formats.FormatGeoJSON,
                        formats.FormatMBTiles,
                        formats.FormatMapsforge,
                        formats.FormatOsmGz,
                        formats.FormatOsmPbf,
                        formats.FormatPoly,
                        formats.FormatShpZip,
                },
                Meta: false,
        }

        slog.Debug("Add", "name", name)

        if err := b.Config.MergeElement(&amp;myElement); err != nil </span><span class="cov0" title="0">{
                slog.Error("Can't merge element", "name", myElement.Name, "error", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package geofabrik

import (
        "errors"
        "log/slog"
        "regexp"

        "github.com/gocolly/colly/v2"
        "github.com/julien-noblet/download-geofabrik/internal/element"
        "github.com/julien-noblet/download-geofabrik/internal/scrapper"
        "github.com/julien-noblet/download-geofabrik/pkg/formats"
)

// Constants for magic numbers and URLs.
const (
        progressBarCount = 509 // number of elements
        parallelism      = 20  // number of parallel downloads
        baseURL          = "https://download.geofabrik.de"
        startURL         = baseURL + "/"
)

// Geofabrik Scrapper.
type Geofabrik struct {
        *scrapper.Scrapper
}

// GetDefault returns the default configuration for Geofabrik scrapper.
func GetDefault() *Geofabrik <span class="cov6" title="8">{
        urlFilters := []*regexp.Regexp{
                regexp.MustCompile(`https://download\.geofabrik\.de/.+\.html$`),
                regexp.MustCompile(`https://download\.geofabrik\.de/$`),
        }

        formatDefinition := formats.FormatDefinitions{
                "osm.bz2.md5":         {ID: "osm.bz2.md5", Loc: "-latest.osm.bz2.md5"},
                "osm.pbf.md5":         {ID: "osm.pbf.md5", Loc: "-latest.osm.pbf.md5"},
                formats.FormatKml:     {ID: formats.FormatKml, Loc: ".kml"},
                formats.FormatMBTiles: {ID: formats.FormatMBTiles, Loc: "-latest-free.mbtiles.zip", ToLoc: "latest-free.mbtiles.zip"},
                formats.FormatOsmBz2:  {ID: formats.FormatOsmBz2, Loc: "-latest.osm.bz2"},
                formats.FormatOsmPbf:  {ID: formats.FormatOsmPbf, Loc: "-latest.osm.pbf"},
                formats.FormatPoly:    {ID: formats.FormatPoly, Loc: ".poly"},
                formats.FormatShpZip:  {ID: formats.FormatShpZip, Loc: "-shortbread-1.0.mbtiles"},
                formats.FormatState:   {ID: formats.FormatState, Loc: "-updates/state.txt"},
        }

        return &amp;Geofabrik{
                Scrapper: &amp;scrapper.Scrapper{
                        PB:               progressBarCount,
                        Async:            true,
                        Parallelism:      parallelism,
                        MaxDepth:         0,
                        AllowedDomains:   []string{`download.geofabrik.de`},
                        BaseURL:          baseURL,
                        StartURL:         startURL,
                        URLFilters:       urlFilters,
                        FormatDefinition: formatDefinition,
                },
        }
}</span>

// Collector represents Geofabrik's scrapper.
func (g *Geofabrik) Collector() *colly.Collector <span class="cov4" title="4">{
        myCollector := g.Scrapper.Collector()
        myCollector.OnHTML("#subregions", func(e *colly.HTMLElement) </span><span class="cov0" title="0">{
                g.ParseSubregion(e, myCollector)
        }</span>)
        <span class="cov4" title="3">myCollector.OnHTML("#specialsubregions", func(e *colly.HTMLElement) </span><span class="cov0" title="0">{
                g.ParseSubregion(e, myCollector)
        }</span>)
        <span class="cov4" title="4">myCollector.OnHTML("li", func(e *colly.HTMLElement) </span><span class="cov0" title="0">{
                g.ParseLi(e, myCollector)
        }</span>)

        <span class="cov4" title="3">return myCollector</span>
}

// ParseSubregion parses the subregion information from the HTML.
func (g *Geofabrik) ParseSubregion(e *colly.HTMLElement, myCollector *colly.Collector) <span class="cov4" title="4">{
        e.ForEach("td.subregion", func(_ int, el *colly.HTMLElement) </span><span class="cov9" title="19">{
                el.ForEach("a", func(_ int, sub *colly.HTMLElement) </span><span class="cov9" title="19">{
                        href := sub.Request.AbsoluteURL(sub.Attr("href"))
                        myID, extension := scrapper.FileExt(href)

                        if extension == "html" </span><span class="cov9" title="19">{
                                g.handleHTMLExtension(sub, href, myID, myCollector)
                        }</span>
                })
        })
}

// handleHTMLExtension handles the HTML extension case.
func (g *Geofabrik) handleHTMLExtension(sub *colly.HTMLElement, href, myID string, myCollector *colly.Collector) <span class="cov9" title="19">{
        parent, parentPath := scrapper.GetParent(href)
        myID, file := g.handleSpecialCases(myID, parent)

        myElement := element.Element{
                ID:     myID,
                Name:   sub.Text,
                Parent: parent,
                Meta:   true,
                File:   file,
        }

        if !g.Config.Exist(parent) &amp;&amp; parent != "" </span><span class="cov1" title="1">{
                gparent, _ := scrapper.GetParent(parentPath)
                slog.Debug("Create Meta", "parent", myElement.Parent, "gparent", gparent, "path", parentPath)

                if gp := element.CreateParentElement(&amp;myElement, gparent); gp != nil </span><span class="cov1" title="1">{
                        if err := g.Config.MergeElement(gp); err != nil </span><span class="cov0" title="0">{
                                slog.Error("Can't merge", "name", myElement.Name, "error", err)
                        }</span>
                }
        }

        <span class="cov9" title="19">if err := g.Config.MergeElement(&amp;myElement); err != nil </span><span class="cov0" title="0">{
                slog.Error("Can't merge", "name", myElement.Name, "error", err)
        }</span>

        <span class="cov9" title="19">slog.Debug("Add", "href", href)

        if err := myCollector.Visit(href); err != nil &amp;&amp; !errors.Is(err, &amp;colly.AlreadyVisitedError{}) </span><span class="cov0" title="0">{
                slog.Error("Can't get url", "error", err)
        }</span>
}

// handleSpecialCases handles special cases for certain IDs.
func (g *Geofabrik) handleSpecialCases(myID, parent string) (newID, file string) <span class="cov10" title="23">{
        const georgia = "georgia"

        switch myID </span>{
        case georgia:<span class="cov4" title="4">
                switch parent </span>{
                case "us":<span class="cov2" title="2">
                        myID = georgia + "-us"
                        file = georgia</span>

                case "europe":<span class="cov2" title="2">
                        myID = georgia + "-eu"
                        file = georgia</span>
                }

        case "guatemala":<span class="cov2" title="2">
                if parent == "south-america" </span><span class="cov2" title="2">{
                        myID = "guatemala-south-america"
                        file = "guatemala"
                }</span>
        }

        <span class="cov10" title="23">return myID, file</span>
}

// ParseFormat adds extensions to the ID.
func (g *Geofabrik) ParseFormat(id, format string) <span class="cov8" title="13">{
        g.Scrapper.ParseFormat(id, format)

        if format == formats.FormatOsmPbf </span><span class="cov6" title="7">{
                g.Config.AddExtension(id, formats.FormatKml)
                g.Config.AddExtension(id, formats.FormatState)
        }</span>
}

// ParseLi parses the list items from the HTML.
func (g *Geofabrik) ParseLi(e *colly.HTMLElement, _ *colly.Collector) <span class="cov4" title="4">{
        e.ForEach("a", func(_ int, element *colly.HTMLElement) </span><span class="cov4" title="4">{
                _, format := scrapper.FileExt(element.Attr("href"))

                myID, _ := scrapper.FileExt(element.Request.URL.String())
                grandParent, _ := scrapper.GetParent(element.Request.AbsoluteURL(element.Attr("href")))
                myID, _ = g.handleSpecialCases(myID, grandParent)

                g.ParseFormat(myID, format)
        }</span>)
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package openstreetmapfr

import (
        "errors"
        "fmt"
        "log/slog"
        "regexp"
        "strings"
        "sync"
        "time"

        "github.com/gocolly/colly/v2"
        "github.com/julien-noblet/download-geofabrik/internal/config"
        "github.com/julien-noblet/download-geofabrik/internal/element"
        "github.com/julien-noblet/download-geofabrik/internal/scrapper"
        "github.com/julien-noblet/download-geofabrik/pkg/formats"
)

// OpenstreetmapFR Scrapper.
type OpenstreetmapFR struct {
        *scrapper.Scrapper
}

const (
        defaultTimeout      = time.Second * 30
        passList            = "HEADER"
        nbElmt              = 1196            // Number of elements in openstreetmap.fr
        parallelism         = 20              // use 20 routines to scrape openstreetmap.fr
        randomDelay         = time.Second * 5 // Random delay between 0 and 5 seconds
        minParentListLength = 4
)

var exceptionList = map[string]struct{}{
        "central":       {},
        "central-east":  {},
        "central-north": {},
        "central-south": {},
        "central-west":  {},
        "central_east":  {},
        "central_north": {},
        "central_south": {},
        "central_west":  {},
        "coastral":      {},
        "east":          {},
        "east_central":  {},
        "east-central":  {},
        "eastern":       {},
        "lake":          {},
        "north":         {},
        "north_central": {},
        "north-central": {},
        "north-east":    {},
        "north-eastern": {},
        "north-west":    {},
        "north-western": {},
        "north_east":    {},
        "north_eastern": {},
        "north_west":    {},
        "north_western": {},
        "northeast":     {},
        "northern":      {},
        "northwest":     {},
        "south":         {},
        "south_central": {},
        "south-central": {},
        "south-east":    {},
        "south-south":   {},
        "south-west":    {},
        "south_east":    {},
        "south_south":   {},
        "south_west":    {},
        "southeast":     {},
        "southern":      {},
        "southwest":     {},
        "west":          {},
        "west_central":  {},
        "west-central":  {},
        "western":       {},
        "france_taaf":   {},
        "sevastopol":    {},
        "la_rioja":      {},
        "jura":          {},
        "santa_cruz":    {},
}

// GetDefault returns a default instance of OpenstreetmapFR.
func GetDefault() *OpenstreetmapFR <span class="cov8" title="17">{
        timeout := defaultTimeout

        return &amp;OpenstreetmapFR{
                Scrapper: &amp;scrapper.Scrapper{
                        PB:             nbElmt,
                        Async:          true,
                        Parallelism:    parallelism,
                        MaxDepth:       0,
                        AllowedDomains: []string{`download.openstreetmap.fr`},
                        BaseURL:        `https://download.openstreetmap.fr/extracts`,
                        StartURL:       `https://download.openstreetmap.fr/`,
                        URLFilters: []*regexp.Regexp{
                                regexp.MustCompile(`https://download\.openstreetmap\.fr/$`),
                                regexp.MustCompile(`https://download\.openstreetmap\.fr/extracts/(\w.+|)$`), //nolint:gocritic // This is a valid regexp
                                regexp.MustCompile(`https://download\.openstreetmap\.fr/polygons/(\w.+|)$`), //nolint:gocritic // This is a valid regexp
                                regexp.MustCompile(`https://download.openstreetmap.fr/cgi-bin/^(.*)$`),      //nolint:gocritic // This is a valid regexp
                                regexp.MustCompile(`https://download.openstreetmap.fr/replication/^(.*|)$`), //nolint:gocritic // This is a valid regexp
                        },
                        FormatDefinition: formats.FormatDefinitions{
                                "osm.pbf.md5":        {ID: "osm.pbf.md5", Loc: "-latest.osm.pbf.md5", ToLoc: "", BasePath: "", BaseURL: ""},
                                formats.FormatOsmPbf: {ID: formats.FormatOsmPbf, Loc: "-latest.osm.pbf", ToLoc: "", BasePath: "", BaseURL: ""},
                                formats.FormatPoly:   {ID: formats.FormatPoly, Loc: ".poly", ToLoc: "", BasePath: "../polygons/", BaseURL: ""},
                                formats.FormatState:  {ID: formats.FormatState, Loc: ".state.txt", ToLoc: "", BasePath: "", BaseURL: ""},
                        },
                        Timeout: timeout,
                        Config: &amp;config.Config{
                                Formats:       formats.FormatDefinitions{},
                                Elements:      element.MapElement{},
                                ElementsMutex: &amp;sync.RWMutex{},
                                BaseURL:       `https://download.openstreetmap.fr/`,
                        },
                        DomainGlob:  "*",
                        RandomDelay: randomDelay,
                },
        }
}</span>

// Collector returns a Colly collector for OpenstreetmapFR.
func (o *OpenstreetmapFR) Collector() *colly.Collector <span class="cov3" title="3">{
        c := o.Scrapper.Collector()
        c.OnHTML("a", func(e *colly.HTMLElement) </span><span class="cov0" title="0">{
                o.Parse(e, c)
        }</span>)

        <span class="cov3" title="3">return c</span>
}

// GetParent returns the parent and the list of parents from a given href.
func GetParent(href string) (parent string, parentList []string) <span class="cov9" title="27">{
        // Remove the last / from the href to avoid empty string in the parent list
        href = strings.TrimSuffix(href, "/")

        parentList = strings.Split(href, "/")
        if len(parentList) &gt; minParentListLength </span><span class="cov9" title="23">{
                parent = parentList[len(parentList)-2]
        }</span> else<span class="cov4" title="4"> {
                parent = ""
        }</span>

        <span class="cov9" title="27">if strings.EqualFold(parent, "extracts") || strings.EqualFold(parent, "polygons") </span><span class="cov5" title="5">{
                parent = ""
        }</span>

        <span class="cov9" title="27">return parent, parentList</span>
}

// MakeParents creates parent elements recursively.
func (o *OpenstreetmapFR) MakeParents(parent string, gparents []string) <span class="cov8" title="20">{
        if parent == "" </span><span class="cov5" title="5">{
                return
        }</span>

        <span class="cov8" title="15">gparent := getGparent(gparents)

        if !o.Config.Exist(parent) </span><span class="cov8" title="15">{
                o.createAndMergeElement(parent, gparent)

                if gparent != "" </span><span class="cov4" title="4">{
                        o.MakeParents(gparent, gparents[:len(gparents)-1])
                }</span>
        }
}

// getGparent returns the grandparent from a list of parents.
func getGparent(gparents []string) string <span class="cov8" title="15">{
        if len(gparents) &lt; minParentListLength </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov7" title="14">gparent := gparents[len(gparents)-3]
        if gparent == "http:" || gparent == "openstreetmap.fr" || gparent == "extracts" || gparent == "polygons" </span><span class="cov7" title="10">{
                return ""
        }</span>

        <span class="cov4" title="4">return gparent</span>
}

// createAndMergeElement creates and merges an element into the configuration.
func (o *OpenstreetmapFR) createAndMergeElement(parent, gparent string) <span class="cov8" title="15">{
        myElement := element.Element{
                Parent:  gparent,
                Name:    parent,
                ID:      parent,
                Formats: []string{},
                File:    "",
                Meta:    true,
        }

        if err := o.Config.MergeElement(&amp;myElement); err != nil </span><span class="cov0" title="0">{
                slog.Error("Can't merge", "name", myElement.Name, "error", err)
        }</span>
}

// Exceptions returns the exception name if it exists in the exception list.
func Exceptions(name, parent string) string <span class="cov8" title="17">{
        if _, exists := exceptionList[name]; exists </span><span class="cov2" title="2">{
                return fmt.Sprintf("%v_%v", parent, name)
        }</span>

        <span class="cov8" title="15">return name</span>
}

// ParseHref parses the href and updates the configuration.
func (o *OpenstreetmapFR) ParseHref(href string) <span class="cov10" title="30">{
        slog.Debug("Parsing", "href", href)

        if strings.Contains(href, "?") || strings.Contains(href, "-latest") || href[0] == '/' </span><span class="cov7" title="12">{
                return
        }</span>

        <span class="cov8" title="18">parent, parents := GetParent(href)
        if !o.Config.Exist(parent) </span><span class="cov7" title="11">{
                o.MakeParents(parent, parents)
        }</span>

        <span class="cov8" title="18">valsplit := strings.Split(parents[len(parents)-1], ".")
        if valsplit[0] == "" || len(strings.Split(href, "/")) &lt;= minParentListLength </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov8" title="17">if strings.Contains(passList, valsplit[0]) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="17">name := Exceptions(valsplit[0], parent)
        slog.Debug("Parsing", "name", name)

        extension := strings.Join(valsplit[1:], ".")
        if strings.Contains(extension, "state.txt") </span><span class="cov5" title="5">{
                extension = formats.FormatState
        }</span>

        <span class="cov8" title="17">slog.Debug("Add format", "extension", extension)

        file := ""
        if extension != "" </span><span class="cov8" title="15">{
                file = name
        }</span>

        <span class="cov8" title="17">o.addOrUpdateElement(parent, name, file, extension)</span>
}

// addOrUpdateElement adds or updates an element in the configuration.
func (o *OpenstreetmapFR) addOrUpdateElement(parent, name, file, extension string) <span class="cov8" title="17">{
        myElement := element.Element{
                ID:      name,
                File:    file,
                Name:    name,
                Parent:  parent,
                Formats: []string{},
                Meta:    false,
        }

        if extension == "" </span><span class="cov2" title="2">{
                myElement.File = ""
                myElement.Meta = true
        }</span>

        <span class="cov8" title="17">if !o.Config.Exist(name) </span><span class="cov7" title="12">{
                if extension != "" </span><span class="cov7" title="10">{
                        myElement.Formats = append(myElement.Formats, extension)
                }</span>

                <span class="cov7" title="12">if err := o.Config.MergeElement(&amp;myElement); err != nil </span><span class="cov0" title="0">{
                        slog.Error("Can't merge", "name", myElement.Name, "error", err)
                }</span>
        } else<span class="cov5" title="5"> {
                slog.Debug("Already exist, merging formats", "name", name)

                if extension != "" </span><span class="cov5" title="5">{
                        o.Config.AddExtension(name, extension)
                }</span>
        }
}

// Parse parses the HTML element and visits the URL if it's a directory.
func (o *OpenstreetmapFR) Parse(e *colly.HTMLElement, c *colly.Collector) <span class="cov9" title="23">{
        href := e.Request.AbsoluteURL(e.Attr("href"))
        if isDirectory(href) </span><span class="cov2" title="2">{
                slog.Debug("Next", "href", href)
                visitURL(c, href)
        }</span> else<span class="cov9" title="21"> {
                o.ParseHref(href)
        }</span>
}

// isDirectory checks if the URL is a directory.
func isDirectory(href string) bool <span class="cov9" title="23">{
        return href[len(href)-1] == '/'
}</span>

// visitURL visits the URL and handles errors.
func visitURL(c *colly.Collector, href string) <span class="cov2" title="2">{
        if err := c.Visit(href); err != nil &amp;&amp; !errors.Is(err, &amp;colly.AlreadyVisitedError{}) </span><span class="cov2" title="2">{
                if !errors.Is(err, colly.ErrNoURLFiltersMatch) </span><span class="cov0" title="0">{
                        slog.Error("Can't get url", "error", err)
                }</span> else<span class="cov2" title="2"> {
                        slog.Debug("URL filtered", "url", href)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package osmtoday

import (
        "errors"
        "fmt"
        "log/slog"
        "regexp"
        "sync"

        "github.com/gocolly/colly/v2"
        "github.com/julien-noblet/download-geofabrik/internal/config"
        "github.com/julien-noblet/download-geofabrik/internal/element"
        "github.com/julien-noblet/download-geofabrik/internal/scrapper"
        "github.com/julien-noblet/download-geofabrik/pkg/formats"
)

// Constants for magic numbers and URLs.
const (
        progressBarCount = 1003 // number of elements
        parallelism      = 20   // number of parallel downloads
        baseURL          = "https://osmtoday.com"
        startURL         = baseURL + "/"
)

// Osmtoday Scrapper.
type Osmtoday struct {
        *scrapper.Scrapper
}

// GetDefault returns the default configuration for Osmtoday scrapper.
func GetDefault() *Osmtoday <span class="cov5" title="14">{
        urlFilters := []*regexp.Regexp{
                regexp.MustCompile(`https://osmtoday\.com/.+\.html$`),
                regexp.MustCompile(`https://osmtoday\.com/$`),
        }

        formatDefinition := formats.FormatDefinitions{
                "osm.pbf.md5":         {ID: "osm.pbf.md5", Loc: ".md5"},
                formats.FormatGeoJSON: {ID: formats.FormatGeoJSON, Loc: ".geojson"},
                formats.FormatOsmPbf:  {ID: formats.FormatOsmPbf, Loc: ".pbf"},
                formats.FormatPoly:    {ID: formats.FormatPoly, Loc: ".poly"},
        }

        return &amp;Osmtoday{
                Scrapper: &amp;scrapper.Scrapper{
                        PB:               progressBarCount,
                        Async:            true,
                        Parallelism:      parallelism,
                        MaxDepth:         0,
                        AllowedDomains:   []string{`osmtoday.com`},
                        BaseURL:          baseURL,
                        StartURL:         startURL,
                        URLFilters:       urlFilters,
                        FormatDefinition: formatDefinition,
                        Config: &amp;config.Config{
                                Formats:       formats.FormatDefinitions{},
                                Elements:      element.MapElement{},
                                ElementsMutex: &amp;sync.RWMutex{},
                                BaseURL:       "",
                        },
                },
        }
}</span>

// Collector represents Osmtoday's scrapper.
func (g *Osmtoday) Collector() *colly.Collector <span class="cov1" title="1">{
        myCollector := g.Scrapper.Collector()
        myCollector.OnHTML(".row", func(e *colly.HTMLElement) </span><span class="cov1" title="1">{
                g.ParseLi(e, myCollector)
        }</span>)
        <span class="cov1" title="1">myCollector.OnHTML("table", func(e *colly.HTMLElement) </span><span class="cov2" title="3">{
                g.ParseSubregion(e, myCollector)
        }</span>)

        <span class="cov1" title="1">return myCollector</span>
}

// Exceptions handles special cases for certain IDs.
func (g *Osmtoday) Exceptions(myElement *element.Element) *element.Element <span class="cov5" title="18">{
        exceptions := []struct {
                ID     string
                Parent string
        }{
                {"la_rioja", "argentina"},
                {"la_rioja", "spain"},
                {"guyane", "france"},
                {"guyane", "south-america"},
                {"sevastopol", "ukraine"},
                {"sevastopol", "russia"},
                {"limburg", "netherlands"},
                {"limburg", "flanders"},
                {"cordoba", "argentina"},
                {"cordoba", "andalucia"},
                {"georgia", "asia"},
                {"georgia", "us"},
        }

        for _, exception := range exceptions </span><span class="cov10" title="216">{
                if myElement.ID == exception.ID &amp;&amp; myElement.Parent == exception.Parent </span><span class="cov5" title="12">{
                        myElement.ID = fmt.Sprintf("%s-%s", myElement.ID, myElement.Parent)
                }</span>
        }

        <span class="cov5" title="18">return myElement</span>
}

// ParseSubregion parses the subregion information from the HTML.
func (g *Osmtoday) ParseSubregion(e *colly.HTMLElement, myCollector *colly.Collector) <span class="cov2" title="3">{
        e.ForEach("td", func(_ int, el *colly.HTMLElement) </span><span class="cov2" title="3">{
                el.ForEach("a", func(_ int, sub *colly.HTMLElement) </span><span class="cov3" title="5">{
                        href := sub.Request.AbsoluteURL(sub.Attr("href"))

                        myID, extension := scrapper.FileExt(href)
                        if myID == "" </span><span class="cov0" title="0">{
                                slog.Debug("myID is empty", "href", href)

                                return
                        }</span>

                        <span class="cov3" title="5">if extension == "html" </span><span class="cov2" title="2">{
                                g.handleHTMLExtension(sub, href, myID, myCollector)
                        }</span> else<span class="cov2" title="3"> {
                                parent, _ := scrapper.GetParent(href)

                                myElement := element.Element{
                                        ID:     myID,
                                        Name:   sub.Text,
                                        Parent: parent,
                                        Meta:   true,
                                }
                                myElement = *g.Exceptions(&amp;myElement)

                                if err := g.Config.MergeElement(&amp;myElement); err != nil </span><span class="cov0" title="0">{
                                        slog.Error("Can't merge", "name", myElement.Name, "error", err)
                                }</span>

                                <span class="cov2" title="3">g.ParseFormat(myElement.ID, extension)</span>
                        }
                })
        })
}

// handleHTMLExtension handles the HTML extension case.
func (g *Osmtoday) handleHTMLExtension(sub *colly.HTMLElement, href, myID string, myCollector *colly.Collector) <span class="cov2" title="2">{
        parent, parentPath := scrapper.GetParent(href)

        myElement := element.Element{
                ID:     myID,
                Name:   sub.Text,
                Parent: parent,
                Meta:   true,
        }

        myElement = *g.Exceptions(&amp;myElement)

        if !g.Config.Exist(parent) &amp;&amp; parent != "" </span><span class="cov0" title="0">{
                gparent, _ := scrapper.GetParent(parentPath)
                slog.Debug("Create Meta", "parent", myElement.Parent, "gparent", gparent, "path", parentPath)

                if gp := element.CreateParentElement(&amp;myElement, gparent); gp != nil </span><span class="cov0" title="0">{
                        if err := g.Config.MergeElement(gp); err != nil </span><span class="cov0" title="0">{
                                slog.Error("Can't merge", "name", myElement.Name, "error", err)
                        }</span>
                }
        }

        <span class="cov2" title="2">if err := g.Config.MergeElement(&amp;myElement); err != nil </span><span class="cov0" title="0">{
                slog.Error("Can't merge", "name", myElement.Name, "error", err)
        }</span>

        <span class="cov2" title="2">slog.Debug("Add", "href", href)

        if err := myCollector.Visit(href); err != nil &amp;&amp; !errors.Is(err, &amp;colly.AlreadyVisitedError{}) </span><span class="cov0" title="0">{
                slog.Error("Can't get url", "error", err)
        }</span>
}

// ParseFormat adds extensions to the ID.
func (g *Osmtoday) ParseFormat(id, format string) <span class="cov3" title="4">{
        g.ParseFormatService(id, format, &amp;g.FormatDefinition)

        if format == formats.FormatOsmPbf </span><span class="cov3" title="4">{
                g.Config.AddExtension(id, "osm.pbf.md5")
        }</span>
}

// ParseLi parses the list items from the HTML.
func (g *Osmtoday) ParseLi(e *colly.HTMLElement, _ *colly.Collector) <span class="cov1" title="1">{
        e.ForEach("a", func(_ int, element *colly.HTMLElement) </span><span class="cov1" title="1">{
                _, format := scrapper.FileExt(element.Attr("href"))
                myID, _ := scrapper.FileExt(element.Request.URL.String())

                g.ParseFormat(myID, format)
        }</span>)
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package scrapper

import (
        "errors"
        "log/slog"
        "net"
        "net/http"
        "regexp"
        "strings"
        "sync"
        "time"

        "github.com/gocolly/colly/v2"
        "github.com/julien-noblet/download-geofabrik/internal/config"
        "github.com/julien-noblet/download-geofabrik/internal/element"
        "github.com/julien-noblet/download-geofabrik/pkg/formats"
)

// IScrapper represents a colly Scrapper.
type IScrapper interface {
        GetConfig() *config.Config
        Collector() *colly.Collector
        Limit() *colly.LimitRule
        GetPB() int
        GetStartURL() string
        ParseFormat(id, format string)
}

// Scrapper defines a default scrapper.
type Scrapper struct {
        Config           *config.Config
        FormatDefinition formats.FormatDefinitions
        BaseURL          string
        DomainGlob       string
        StartURL         string
        URLFilters       []*regexp.Regexp
        AllowedDomains   []string
        Timeout          time.Duration
        RandomDelay      time.Duration
        MaxDepth         int
        Parallelism      int
        PB               int
        mu               sync.RWMutex
        Async            bool
}

const (
        defaultRandomDelay           = 5 * time.Second
        defaultTimeout               = 60 * time.Second
        defaultKeepAlive             = 30 * time.Second
        defaultIdleConnTimeout       = 5 * time.Second
        defaultTLSHandshakeTimeout   = 10 * time.Second
        defaultExpectContinueTimeout = 5 * time.Second
        minParentListLength          = 5
)

// NewScrapper creates a new Scrapper instance with default values.
func NewScrapper(baseURL, startURL string, allowedDomains []string) *Scrapper <span class="cov0" title="0">{
        return &amp;Scrapper{
                RandomDelay:    defaultRandomDelay,
                Timeout:        defaultTimeout,
                Parallelism:    1,
                BaseURL:        baseURL,
                StartURL:       startURL,
                AllowedDomains: allowedDomains,
        }
}</span>

// GetConfig initializes a *config.Config from fields.
func (s *Scrapper) GetConfig() *config.Config <span class="cov5" title="25">{
        s.mu.RLock()

        if s.Config != nil </span><span class="cov4" title="12">{
                defer s.mu.RUnlock()

                return s.Config
        }</span>

        <span class="cov4" title="14">s.mu.RUnlock()

        s.mu.Lock()
        defer s.mu.Unlock()

        s.Config = s.initializeConfig()

        return s.Config</span>
}

// initializeConfig initializes the configuration with default values.
func (s *Scrapper) initializeConfig() *config.Config <span class="cov4" title="14">{
        return &amp;config.Config{
                Elements:      element.MapElement{},
                ElementsMutex: &amp;sync.RWMutex{},
                Formats:       s.FormatDefinition,
                BaseURL:       s.BaseURL,
        }
}</span>

// Limit defines LimitRules.
func (s *Scrapper) Limit() *colly.LimitRule <span class="cov4" title="13">{
        if s.DomainGlob == "" </span><span class="cov3" title="8">{
                s.DomainGlob = "*"
        }</span>

        <span class="cov4" title="13">if s.Parallelism &lt;= 1 </span><span class="cov2" title="3">{
                s.Parallelism = 1
        }</span>

        <span class="cov4" title="13">return &amp;colly.LimitRule{
                DomainGlob:  s.DomainGlob,
                Parallelism: s.Parallelism,
                RandomDelay: s.RandomDelay,
        }</span>
}

// Collector initializes a *colly.Collector.
func (s *Scrapper) Collector(_ ...interface{}) *colly.Collector <span class="cov3" title="10">{
        myCollector := colly.NewCollector(
                colly.AllowedDomains(s.AllowedDomains...),
                colly.URLFilters(s.URLFilters...),
                colly.Async(s.Async),
                colly.MaxDepth(s.MaxDepth),
        )

        if s.Timeout != 0 </span><span class="cov2" title="3">{
                myCollector.SetRequestTimeout(s.Timeout)
        }</span>

        <span class="cov3" title="9">myCollector.WithTransport(&amp;http.Transport{
                Proxy: http.ProxyFromEnvironment,
                DialContext: (&amp;net.Dialer{
                        Timeout:   defaultTimeout,
                        KeepAlive: defaultKeepAlive,
                }).DialContext,
                IdleConnTimeout:       defaultIdleConnTimeout,
                TLSHandshakeTimeout:   defaultTLSHandshakeTimeout,
                ExpectContinueTimeout: defaultExpectContinueTimeout,
        })

        s.Config = s.GetConfig()
        if err := myCollector.Limit(s.Limit()); err != nil </span><span class="cov0" title="0">{
                slog.Error("Can't update limit", "error", err)
        }</span>

        <span class="cov3" title="10">myCollector.OnError(func(r *colly.Response, err error) </span><span class="cov0" title="0">{
                if !errors.Is(err, colly.ErrForbiddenURL) &amp;&amp; !errors.Is(err, colly.ErrForbiddenDomain) &amp;&amp; err.Error() != "Forbidden" </span><span class="cov0" title="0">{
                        slog.Debug("Request failed", "url", r.Request.URL, "error", err)
                }</span> else<span class="cov0" title="0"> {
                        slog.Debug("Forbidden URL", "url", r.Request.URL)
                }</span>
        })

        <span class="cov3" title="10">return myCollector</span>
}

// GetStartURL returns StartURL.
func (s *Scrapper) GetStartURL() string <span class="cov10" title="1024">{
        return s.StartURL
}</span>

// GetPB returns PB.
func (s *Scrapper) GetPB() int <span class="cov3" title="10">{
        return s.PB
}</span>

// ParseFormat adds Extensions to ID.
func (s *Scrapper) ParseFormat(id, format string) <span class="cov5" title="22">{
        s.AddExtension(id, format, &amp;s.Config.Formats)
}</span>

// ParseFormatService adds Extensions to ID.
func (s *Scrapper) ParseFormatService(id, format string, def *formats.FormatDefinitions) <span class="cov2" title="4">{
        s.AddExtension(id, format, def)
}</span>

// AddExtension adds an extension to the configuration.
func (s *Scrapper) AddExtension(id, format string, def *formats.FormatDefinitions) <span class="cov5" title="26">{
        for f, i := range *def </span><span class="cov8" title="232">{
                if format == i.ID </span><span class="cov5" title="24">{
                        s.Config.AddExtension(id, f)
                }</span>
        }
}

// FileExt returns filename and extension.
func FileExt(url string) (filename, extension string) <span class="cov5" title="38">{
        urls := strings.Split(url, "/")
        f := strings.Split(urls[len(urls)-1], ".")

        return f[0], strings.Join(f[1:], ".")
}</span>

// GetParent returns filename and path.
func GetParent(url string) (filename, path string) <span class="cov5" title="33">{
        r := strings.Split(url, "/")
        if len(r) &lt; minParentListLength </span><span class="cov4" title="12">{
                return "", strings.Join(r[:len(r)-1], "/")
        }</span>

        <span class="cov4" title="21">return r[len(r)-2], strings.Join(r[:len(r)-1], "/")</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package formats

import (
        "sort"
        "strings"
)

// Format represents a file format with various attributes.
type Format struct {
        ID       string `yaml:"ext"`
        Loc      string `yaml:"loc"`
        BasePath string `yaml:"basepath,omitempty"`
        BaseURL  string `yaml:"baseurl,omitempty"`
        ToLoc    string `yaml:"toloc,omitempty"`
        Type     string `yaml:"type,omitempty"` // Added to match new config, though original didn't have it explicit?
}

// FormatDefinitions is a map of format definitions.
type FormatDefinitions map[string]Format

// MiniFormat represents a short and full name pair for a format.
type MiniFormat struct {
        ShortName string
        FullName  string
}

const (
        FormatState          = "state"
        FormatOsmPbf         = "osm.pbf"
        FormatOsmGz          = "osm.gz"
        FormatOsmBz2         = "osm.bz2"
        FormatOshPbf         = "osh.pbf"
        FormatPoly           = "poly"
        FormatShpZip         = "shp.zip"
        FormatKml            = "kml"
        FormatGeoJSON        = "geojson"                        // BBBike &amp; OSM Today only
        FormatGarminOntrail  = "osm.garmin-ontrail-latin1.zip"  // BBBike only
        FormatGarminOnroad   = "osm.garmin-onroad-latin1.zip"   // BBBike only
        FormatGarminOpenTopo = "osm.garmin-opentopo-latin1.zip" // BBBike only
        FormatGarminOSM      = "osm.garmin-osm.zip"             // BBBike only
        FormatMapsforge      = "osm.mapsforge-osm.zip"          // BBBike only
        FormatMBTiles        = "mbtiles"
        FormatCSV            = "csv" // BBBike only
)

// Configuration keys.
const (
        KeyOsmPbf         = "dosmPbf"
        KeyOshPbf         = "doshPbf"
        KeyOsmGz          = "dosmGz"
        KeyOsmBz2         = "dosmBz2"
        KeyShpZip         = "dshpZip"
        KeyState          = "dstate"
        KeyPoly           = "dpoly"
        KeyKml            = "dkml"
        KeyGeoJSON        = "dgeojson"
        KeyGarminOSM      = "dgarmin"
        KeyMapsforge      = "dmaps"
        KeyMBTiles        = "dmbtiles"
        KeyCSV            = "dcsv"
        KeyGarminOnroad   = "dgarminonroad"
        KeyGarminOntrail  = "dgarminontrail"
        KeyGarminOpenTopo = "dgarminopentopo"
)

// GetMiniFormats returns a string of short format names based on the provided full format names.
func GetMiniFormats(fullFormatNames []string) string <span class="cov6" title="25">{
        miniFormats := []MiniFormat{
                {ShortName: "s", FullName: FormatState},
                {ShortName: "P", FullName: FormatOsmPbf},
                {ShortName: "G", FullName: FormatOsmGz},
                {ShortName: "B", FullName: FormatOsmBz2},
                {ShortName: "H", FullName: FormatOshPbf},
                {ShortName: "p", FullName: FormatPoly},
                {ShortName: "S", FullName: FormatShpZip},
                {ShortName: "k", FullName: FormatKml},
                {ShortName: "g", FullName: FormatGeoJSON},
                {ShortName: "t", FullName: FormatGarminOntrail},
                {ShortName: "r", FullName: FormatGarminOnroad},
                {ShortName: "o", FullName: FormatGarminOpenTopo},
                {ShortName: "O", FullName: FormatGarminOSM},
                {ShortName: "m", FullName: FormatMapsforge},
                {ShortName: "M", FullName: FormatMBTiles},
                {ShortName: "C", FullName: FormatCSV},
        }

        shortNames := make([]string, 0, len(fullFormatNames))

        for _, fullName := range fullFormatNames </span><span class="cov7" title="41">{
                for _, format := range miniFormats </span><span class="cov10" title="222">{
                        if fullName == format.FullName </span><span class="cov6" title="36">{
                                shortNames = append(shortNames, format.ShortName)

                                break</span>
                        }
                }
        }

        <span class="cov6" title="25">return strings.Join(shortNames, "")</span>
}

// GetFormats returns a slice of format strings based on the configuration map.
// The config map should contain keys like KeyOsmPbf with boolean true/false.
func GetFormats(config map[string]bool) []string <span class="cov4" title="9">{
        options := map[string]string{
                KeyOsmPbf:         FormatOsmPbf,
                KeyOshPbf:         FormatOshPbf,
                KeyOsmGz:          FormatOsmGz,
                KeyOsmBz2:         FormatOsmBz2,
                KeyShpZip:         FormatShpZip,
                KeyState:          FormatState,
                KeyPoly:           FormatPoly,
                KeyKml:            FormatKml,
                KeyGeoJSON:        FormatGeoJSON,
                KeyGarminOSM:      FormatGarminOSM,
                KeyMapsforge:      FormatMapsforge,
                KeyMBTiles:        FormatMBTiles,
                KeyCSV:            FormatCSV,
                KeyGarminOnroad:   FormatGarminOnroad,
                KeyGarminOntrail:  FormatGarminOntrail,
                KeyGarminOpenTopo: FormatGarminOpenTopo,
        }

        var formatList []string

        for key, format := range options </span><span class="cov9" title="144">{
                if enabled, ok := config[key]; ok &amp;&amp; enabled </span><span class="cov4" title="11">{
                        formatList = append(formatList, format)
                }</span>
        }

        <span class="cov4" title="9">if len(formatList) == 0 </span><span class="cov1" title="1">{
                formatList = append(formatList, FormatOsmPbf)
        }</span>

        <span class="cov4" title="9">sort.Strings(formatList)

        return formatList</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
